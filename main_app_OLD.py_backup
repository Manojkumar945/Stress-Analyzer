from flask import Flask, jsonify, render_template, request, session, redirect, url_for
import requests
import pandas as pd
import numpy as np
import time
import random
import threading
import joblib
import json
from datetime import datetime, timedelta
from collections import deque
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import csv
import io
import sqlite3
import os
import hashlib

# ==========================================
# CONFIGURATION
# ==========================================
IOT_READ_URL = "https://iotcloud22.in/4503_eeg/light.json"
IOT_POST_URL = "https://iotcloud22.in/4503_eeg/post_value1.php"
MODEL_PATH = "stress_rf_model.pkl"

# Notification Settings
EMAIL_ENABLED = True
SMS_ENABLED = True
SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587
# USER MUST UPDATE THESE FOR REAL EMAILS
EMAIL_ADDRESS = "cybertechguard28@gmail.com"
EMAIL_PASSWORD = os.getenv("EMAIL_PASSWORD", "xxxx xxxx xxxx xxxx") # App Password

# SMS Settings (using Twilio or similar service)
TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID", "")
TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN", "")
TWILIO_PHONE_NUMBER = os.getenv("TWILIO_PHONE_NUMBER", "")

# Fallback email if no caretakers registered
CARETAKER_EMAIL = os.getenv("CARETAKER_EMAIL", "caretaker@example.com")

# Database
DB_PATH = "eeg_monitoring.db"

app = Flask(__name__)
app.secret_key = os.urandom(24)

# Load ML model
try:
    model = joblib.load(MODEL_PATH)
    print("‚úÖ Model loaded successfully")
except Exception as e:
    print(f"‚ö†Ô∏è Error loading model: {e}")
    model = None

# Therapy songs and relaxation techniques
THERAPY_CONTENT = {
    "normal": {
        "songs": [
            {"name": "Calm Piano", "url": "https://www.youtube.com/watch?v=2Vv-BfVoq4g"},
            {"name": "Nature Sounds", "url": "https://www.youtube.com/watch?v=wp43OdtAAkM"},
            {"name": "Meditation Music", "url": "https://www.youtube.com/watch?v=JGwWNGJdvx8"},
            {"name": "Ambient Soundscape", "url": "https://www.youtube.com/watch?v=7NOSDKb0HlU"},
            {"name": "Peaceful Melody", "url": "https://www.youtube.com/watch?v=60ItHLz5WEA"}
        ],
        "techniques": [
            "Deep Breathing: Practice slow inhalation for 4 seconds, hold for 4 seconds, and exhale for 4 seconds.",
            "Mindful Listening: Focus on calm background music or natural sounds to maintain relaxation.",
            "Gentle Stretching: Do light neck and shoulder stretches to keep muscles relaxed.",
            "Positive Affirmations: Repeat short positive phrases like \"I feel calm and focused.\""
        ]
    },
    "stress": {
        "songs": [
            {"name": "Deep Relaxation", "url": "https://www.youtube.com/watch?v=hTWKbfoikeg"},
            {"name": "Stress Relief", "url": "https://www.youtube.com/watch?v=3mbBbFH9fAg"},
            {"name": "Calming Waves", "url": "https://www.youtube.com/watch?v=5abamRO41fE"},
            {"name": "Peaceful Mind", "url": "https://www.youtube.com/watch?v=fJ9rUzIMcZQ"},
            {"name": "Relaxation Therapy", "url": "https://www.youtube.com/watch?v=l482T0yNkeo"}
        ],
        "techniques": [
            "Progressive Muscle Relaxation: Tense and then slowly release each muscle group to relieve tension.",
            "Box Breathing: Inhale for 4 seconds, hold for 4 seconds, exhale for 4 seconds, and pause for 4 seconds.",
            "Guided Imagery: Visualize a peaceful scene such as a beach or garden to calm the mind.",
            "Soothing Music Therapy: Play soft instrumental or meditation music to reduce stress hormones."
        ]
    },
    "anxiety": {
        "songs": [
            {"name": "Anxiety Relief", "url": "https://www.youtube.com/watch?v=WIF4_Sm-rgQ"},
            {"name": "Soothing Sounds", "url": "https://www.youtube.com/watch?v=1WLWmDZ3Q6I"},
            {"name": "Calm Your Mind", "url": "https://www.youtube.com/watch?v=3JWTaaS7LdU"},
            {"name": "Peaceful Journey", "url": "https://www.youtube.com/watch?v=3AtDnEC4zak"},
            {"name": "Tranquil Moments", "url": "https://www.youtube.com/watch?v=3YxaaGgTQYM"}
        ],
        "techniques": [
            "Grounding Technique (5-4-3-2-1): Name 5 things you see, 4 you touch, 3 you hear, 2 you smell, 1 you taste ‚Äî helps focus on the present.",
            "Alternate Nostril Breathing: Breathe in through one nostril, out through the other ‚Äî balances brain activity and calms anxiety.",
            "Aromatherapy: Use lavender or chamomile scents to relax the nervous system.",
            "Mindfulness Meditation: Focus on your breath and let thoughts pass without judgment."
        ]
    }
}

# ==========================================
# DATABASE SETUP
# ==========================================
def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    # EEG Data Table - stores aggregated predictions (every 10 seconds)
    c.execute('''CREATE TABLE IF NOT EXISTS eeg_data
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  timestamp TEXT NOT NULL,
                  eeg_value REAL,
                  mean_val REAL,
                  std_val REAL,
                  peak_amp REAL,
                  heart_rate REAL,
                  rr_var REAL,
                  entropy REAL,
                  prediction TEXT,
                  session_id TEXT)''')
    
    # EEG Readings Table - stores second-by-second raw EEG values
    c.execute('''CREATE TABLE IF NOT EXISTS eeg_readings
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  timestamp TEXT NOT NULL,
                  eeg_value REAL NOT NULL,
                  session_id TEXT,
                  reading_index INTEGER)''')
    
    # Create index on timestamp for faster queries
    c.execute('''CREATE INDEX IF NOT EXISTS idx_timestamp ON eeg_readings(timestamp)''')
    c.execute('''CREATE INDEX IF NOT EXISTS idx_session ON eeg_readings(session_id)''')
    
    # Caretakers Table
    c.execute('''CREATE TABLE IF NOT EXISTS caretakers
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT NOT NULL,
                  username TEXT NOT NULL UNIQUE,
                  password_hash TEXT NOT NULL,
                  mobile_number TEXT NOT NULL,
                  email TEXT NOT NULL,
                  registered_at TEXT NOT NULL,
                  is_active INTEGER DEFAULT 1,
                  UNIQUE(email, mobile_number),
                  UNIQUE(username))''')
    
    # Add username and password_hash columns if they don't exist (for existing databases)
    try:
        c.execute('''ALTER TABLE caretakers ADD COLUMN username TEXT''')
    except sqlite3.OperationalError:
        pass  # Column already exists
    
    try:
        c.execute('''ALTER TABLE caretakers ADD COLUMN password_hash TEXT''')
    except sqlite3.OperationalError:
        pass  # Column already exists
    
    # Patients Table
    c.execute('''CREATE TABLE IF NOT EXISTS patients
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  caretaker_id INTEGER,
                  name TEXT NOT NULL,
                  age INTEGER,
                  gender TEXT,
                  medical_history TEXT,
                  created_at TEXT,
                  FOREIGN KEY(caretaker_id) REFERENCES caretakers(id))''')

    conn.commit()
    conn.close()
    print("‚úÖ Database initialized")

init_db()

# ...

def send_email_notification(subject, body, recipient=CARETAKER_EMAIL, csv_content=None, csv_filename=None):
    """Send email notification to caretaker with optional CSV attachment"""
    if not EMAIL_ENABLED:
        print(f"üìß Email notification (disabled): {subject}")
        return False
    
    # Check if email credentials are configured
    if "xxxx" in EMAIL_PASSWORD or not EMAIL_ADDRESS:
        print(f"‚ö†Ô∏è Email credentials not configured. Simulating email send.")
        print(f"   To: {recipient}")
        print(f"   Subject: {subject}")
        return True # Return True to simulate success for UI testing
    
    try:
        msg = MIMEMultipart()
        msg['From'] = EMAIL_ADDRESS
        msg['To'] = recipient
        msg['Subject'] = subject
        msg.attach(MIMEText(body, 'html'))
        
        # Attach CSV file if provided
        if csv_content and csv_filename:
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(csv_content.encode('utf-8'))
            encoders.encode_base64(part)
            part.add_header(
                'Content-Disposition',
                f'attachment; filename= {csv_filename}'
            )
            msg.attach(part)
            print(f"üìé CSV attachment added: {csv_filename}")
        
        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        server.starttls()
        server.login(EMAIL_ADDRESS, EMAIL_PASSWORD)
        text = msg.as_string()
        server.sendmail(EMAIL_ADDRESS, recipient, text)
        server.quit()
        print(f"‚úÖ Email sent successfully to {recipient}: {subject}")
        return True
    except smtplib.SMTPAuthenticationError as e:
        print(f"‚ùå Email authentication failed: {e}")
        print(f"   Please check your EMAIL_ADDRESS and EMAIL_PASSWORD")
        return False
    except smtplib.SMTPException as e:
        print(f"‚ùå SMTP error: {e}")
        return False
    except Exception as e:
        print(f"‚ùå Email send error: {e}")
        return False

def send_sms_notification(mobile_number, message):
    """Send SMS notification to caretaker (requires Twilio or similar service)"""
    if not SMS_ENABLED or not TWILIO_ACCOUNT_SID:
        print(f"üì± SMS notification (disabled): {message[:50]}...")
        return False
    
    try:
        # Using Twilio API (install: pip install twilio)
        # from twilio.rest import Client
        # client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
        # message = client.messages.create(
        #     body=message,
        #     from_=TWILIO_PHONE_NUMBER,
        #     to=mobile_number
        # )
        # print(f"‚úÖ SMS sent to {mobile_number}")
        # return True
        print(f"üì± SMS notification (Twilio not configured): {mobile_number} - {message[:50]}...")
        return False
    except Exception as e:
        print(f"‚ö†Ô∏è SMS send error: {e}")
        return False

def hash_password(password):
    """Hash password using SHA-256"""
    return hashlib.sha256(password.encode()).hexdigest()

def verify_password(password, password_hash):
    """Verify password against hash"""
    return hash_password(password) == password_hash

def get_active_caretakers():
    """Get all active registered caretakers with verified email and mobile"""
    try:
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''SELECT name, mobile_number, email, username
                     FROM caretakers 
                     WHERE is_active = 1 
                     AND email IS NOT NULL 
                     AND email != ''
                     AND mobile_number IS NOT NULL 
                     AND mobile_number != ''''')
        caretakers = []
        for row in c.fetchall():
            # Verify email and mobile are valid
            email = row[2] if row[2] else ""
            mobile = row[1] if row[1] else ""
            if "@" in email and "." in email and len(mobile) >= 10:
                caretakers.append({
                    "name": row[0],
                    "mobile_number": mobile,
                    "email": email,
                    "username": row[3] if len(row) > 3 else None
                })
        conn.close()
        print(f"üìã Found {len(caretakers)} active caretakers with valid email and mobile")
        return caretakers
    except Exception as e:
        print(f"‚ö†Ô∏è Error fetching caretakers: {e}")
        return []

def send_stress_alert(prediction, features):
    """Send alert to all registered caretakers when stress/anxiety detected - includes caretaker name automatically"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Get all active caretakers
    caretakers = get_active_caretakers()
    
    if not caretakers:
        # Fallback to default email if no caretakers registered
        print("‚ö†Ô∏è No caretakers registered. Sending to default email.")
        if CARETAKER_EMAIL and CARETAKER_EMAIL != "caretaker@example.com":
            subject = f"üö® Alert: {prediction.upper()} Detected - Brainwave Monitoring System"
            email_body = f"""
Alert: {prediction.upper()} Detected

Timestamp: {timestamp}

Current Features:
- Mean Value: {features['mean_val']:.2f}
- Standard Deviation: {features['std_val']:.2f}
- Peak Amplitude: {features['peak_amp']:.2f}
- Heart Rate: {features['heart_rate']:.1f} bpm
- RR Variance: {features['rr_var']:.2f}
- Entropy: {features['entropy']:.2f}

Please check on the patient immediately.
The system is automatically initiating therapy protocols.

Best regards,
Brainwave Monitoring System
"""
            send_email_notification(subject, email_body, CARETAKER_EMAIL)
        else:
            print("‚ö†Ô∏è No default email configured. Please register caretakers.")
        return
    
    # Send personalized alerts to all registered caretakers
    success_count = 0
    failed_count = 0
    for caretaker in caretakers:
        # Personalized email with caretaker name
        # Personalized HTML email with caretaker name
        subject = f"Stress Level Alert - {prediction.upper()} Detected"
        
        # Determine patient name (placeholder logic, ideally linked to session/caretaker)
        patient_name = "Patient" 
        
        # Determine color based on prediction
        alert_color = "#ff0000" if prediction.lower() == "anxiety" else "#ff6600" if prediction.lower() == "stress" else "#28a745"
        
        email_body = f"""
<!DOCTYPE html>
<html>
<head>
<style>
    body {{ font-family: Arial, sans-serif; color: #333; line-height: 1.6; }}
    .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
    .header {{ display: flex; align-items: center; margin-bottom: 20px; }}
    .warning-icon {{ font-size: 24px; margin-right: 10px; }}
    .alert-title {{ color: #dc3545; font-size: 24px; font-weight: bold; margin: 0; }}
    .card {{ background-color: #f8f9fa; border-radius: 5px; padding: 20px; margin-bottom: 20px; }}
    .patient-info {{ margin-bottom: 15px; }}
    .patient-name {{ font-weight: bold; font-size: 18px; }}
    .stress-level {{ color: {alert_color}; font-weight: bold; }}
    .timestamp {{ color: #666; font-size: 14px; }}
    .table {{ width: 100%; border-collapse: collapse; margin-bottom: 20px; }}
    .table th, .table td {{ padding: 12px; text-align: left; border-bottom: 1px solid #dee2e6; }}
    .table th {{ background-color: #e9ecef; font-weight: bold; }}
    .therapy-section {{ background-color: #e3f2fd; border-radius: 5px; padding: 20px; border-left: 5px solid #2196f3; }}
    .therapy-title {{ color: #0d47a1; font-weight: bold; margin-bottom: 10px; display: flex; align-items: center; }}
    .music-icon {{ margin-right: 10px; }}
    .song-link {{ color: #2196f3; text-decoration: none; }}
</style>
</head>
<body>
    <div class="container">
        <div class="header">
            <span class="warning-icon">‚ö†Ô∏è</span>
            <h1 class="alert-title">Stress Level Alert</h1>
        </div>
        
        <p>Dear {caretaker['name']},</p>
        
        <div class="card">
            <div class="patient-info">
                <div class="patient-name">Patient: {patient_name}</div>
                <div>Detected Stress Level: <span class="stress-level">{prediction.upper()}</span></div>
                <div class="timestamp">Time: {timestamp}</div>
            </div>
        </div>
        
        <h3>Vital Signs Summary:</h3>
        <table class="table">
            <tr>
                <th>Parameter</th>
                <th>Value</th>
            </tr>
            <tr>
                <td>Heart Rate</td>
                <td>{features['heart_rate']:.1f} bpm</td>
            </tr>
            <tr>
                <td>Mean EEG Value</td>
                <td>{features['mean_val']:.2f}</td>
            </tr>
            <tr>
                <td>Standard Deviation</td>
                <td>{features['std_val']:.2f}</td>
            </tr>
             <tr>
                <td>Peak Amplitude</td>
                <td>{features['peak_amp']:.2f}</td>
            </tr>
             <tr>
                <td>Entropy</td>
                <td>{features['entropy']:.2f}</td>
            </tr>
        </table>
        
        <div class="therapy-section">
            <div class="therapy-title">
                <span class="music-icon">üéµ</span> Relaxation Music Activated
            </div>
            <p>A calming song has been automatically played for the patient:</p>
            <p><a href="#" class="song-link">Click here to view the song</a></p>
        </div>
        
        <p style="margin-top: 20px; font-size: 12px; color: #999;">
            This is an automated alert from the Brainwave Monitoring System.
        </p>
    </div>
</body>
</html>
"""
        
        # Personalized SMS with caretaker name
        sms_message = f"üö® ALERT for {caretaker['name']}: {prediction.upper()} detected at {timestamp}. Heart Rate: {features['heart_rate']:.1f} bpm. Please check on patient immediately."
        
        # Generate CSV file with EEG activity data
        csv_content = generate_eeg_csv()
        csv_filename = f"eeg_activity_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv" if csv_content else None
        
        # Send email with CSV attachment
        email_success = send_email_notification(subject, email_body, caretaker["email"], csv_content, csv_filename)
        
        # Send SMS
        sms_success = send_sms_notification(caretaker["mobile_number"], sms_message)
        
        if email_success:
            success_count += 1
            print(f"‚úÖ Email alert sent successfully to {caretaker['name']} ({caretaker['email']}, {caretaker['mobile_number']})")
        else:
            failed_count += 1
            print(f"‚ùå Failed to send email alert to {caretaker['name']} ({caretaker['email']})")
            print(f"   Please check email configuration and credentials")
    
    print(f"üìß Email alerts: {success_count} successful, {failed_count} failed out of {len(caretakers)} caretakers")
    
    if success_count == 0 and len(caretakers) > 0:
        print(f"‚ö†Ô∏è WARNING: No emails were sent! Please check:")
        print(f"   1. EMAIL_ADDRESS and EMAIL_PASSWORD environment variables are set")
        print(f"   2. For Gmail, use an App Password (not regular password)")
        print(f"   3. SMTP server settings are correct")

# ==========================================
# GLOBALS
# ==========================================
last_label = None
repeat_count = 0
latest_prediction = "N/A"
current_song = {"name": "None", "url": None}
eeg_buffer = deque(maxlen=1000)  # Circular buffer
eeg_history = deque(maxlen=100)  # For visualization
monitoring_active = False
session_id = None
current_features = {
    "mean_val": 0.0,
    "std_val": 0.0,
    "peak_amp": 0.0,
    "heart_rate": 0.0,
    "rr_var": 0.0,
    "entropy": 0.0
}
alert_sent = {}  # Track alerts to avoid spam

# ==========================================
# BACKGROUND MONITORING THREAD
# ==========================================
def live_monitoring():
    global last_label, repeat_count, latest_prediction, eeg_buffer, current_song
    global monitoring_active, current_features, session_id, alert_sent, eeg_history
    
    start_time = time.time()
    
    while True:
        if monitoring_active:
            # print("DEBUG: Monitoring loop iteration...") # Uncomment for verbose debug
            try:
                # Fetch EEG data from IoT endpoint (REAL EEG BOARD DATA)
                eeg_value = None
                try:
                    response = requests.get(IOT_READ_URL, timeout=1) # Short timeout
                    if response.status_code == 200:
                        data = response.json()
                        # print(f"üì° EEG Data from IoT: {data}")
                        
                        # Try to extract EEG value from different possible JSON formats
                        if "value1" in data:
                            eeg_value = float(data.get("value1", 0))
                        elif "eeg_value" in data:
                            eeg_value = float(data.get("eeg_value", 0))
                        elif "value" in data:
                            eeg_value = float(data.get("value", 0))
                        elif isinstance(data, (int, float)):
                            eeg_value = float(data)
                        elif isinstance(data, list) and len(data) > 0:
                            eeg_value = float(data[0])
                        else:
                            # If format is unknown, try to find numeric value
                            for key, val in data.items():
                                try:
                                    eeg_value = float(val)
                                    break
                                except (ValueError, TypeError):
                                    continue
                        
                        # print(f"‚úÖ EEG Value extracted: {eeg_value}")
                        
                        # If value is the static default (1024) or 0, treat as invalid/static
                        if eeg_value is not None and (eeg_value == 1024 or eeg_value == 0):
                            # print("‚ö†Ô∏è Static/Default value detected. Using simulation.")
                            eeg_value = None # Trigger fallback
                    else:
                        pass # Trigger fallback
                except Exception as e:
                    # print(f"‚ö†Ô∏è IoT Connection Error: {e}")
                    pass # Trigger fallback

                # FALLBACK SIMULATION
                if eeg_value is None:
                    # Simulate a realistic EEG signal (alpha/beta waves mix)
                    t = time.time()
                    # Base baseline (around 400-500) + sine wave (alpha 10Hz) + noise
                    eeg_value = 457 + (20 * np.sin(2 * np.pi * 10 * t)) + random.uniform(-10, 10)
                    # print(f"üì° Using SIMULATED EEG Data: {eeg_value:.2f}")
                
                # Save second-by-second reading to database
                current_timestamp = datetime.now().isoformat()
                try:
                    conn = sqlite3.connect(DB_PATH)
                    c = conn.cursor()
                    reading_count = c.execute('''SELECT COUNT(*) FROM eeg_readings WHERE session_id = ?''', 
                                             (session_id,)).fetchone()[0]
                    c.execute('''INSERT INTO eeg_readings 
                               (timestamp, eeg_value, session_id, reading_index) 
                               VALUES (?, ?, ?, ?)''',
                            (current_timestamp, eeg_value, session_id, reading_count + 1))
                    conn.commit()
                    conn.close()
                except Exception as e:
                    print(f"‚ö†Ô∏è Error saving reading: {e}")
                
                # Add to buffers
                eeg_buffer.append(eeg_value)
                eeg_history.append({
                    "timestamp": current_timestamp,
                    "value": eeg_value
                })

                # Update features in real-time (every 2 seconds) if we have enough data
                if len(eeg_buffer) > 5:
                    try:
                        features_df, features_dict = extract_features(list(eeg_buffer))
                        current_features.update(features_dict)
                    except Exception as e:
                        print(f"‚ö†Ô∏è Error calculating real-time features: {e}")

                # Process every 10 seconds if we have enough data for prediction
                if time.time() - start_time >= 10 and len(eeg_buffer) > 10:
                    features_df, features_dict = extract_features(list(eeg_buffer))
                    current_features = features_dict
                    
                    # Make prediction
                    if model:
                        label = model.predict(features_df)[0]
                        if hasattr(label, 'item'):
                            label = label.item()
                        latest_prediction = str(label)
                    else:
                        # Fallback prediction based on features
                        if features_dict['heart_rate'] > 100:
                            latest_prediction = "anxiety"
                        elif features_dict['heart_rate'] > 85:
                            latest_prediction = "stress"
                        else:
                            latest_prediction = "normal"

                    # Save to database
                    try:
                        conn = sqlite3.connect(DB_PATH)
                        c = conn.cursor()
                        c.execute('''INSERT INTO eeg_data 
                                   (timestamp, eeg_value, mean_val, std_val, peak_amp, 
                                    heart_rate, rr_var, entropy, prediction, session_id)
                                   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',
                                (datetime.now().isoformat(),
                                 float(np.mean(list(eeg_buffer))),
                                 features_dict['mean_val'],
                                 features_dict['std_val'],
                                 features_dict['peak_amp'],
                                 features_dict['heart_rate'],
                                 features_dict['rr_var'],
                                 features_dict['entropy'],
                                 latest_prediction,
                                 session_id))
                        conn.commit()
                        conn.close()
                    except Exception as e:
                        print(f"‚ö†Ô∏è Database error: {e}")

                    # Send alert for stress/anxiety - send when prediction changes to stress/anxiety
                    if latest_prediction in ["stress", "anxiety"]:
                        # Check if this is a new prediction (different from last) or first time
                        prediction_changed = (last_label != label) if last_label is not None else True
                        
                        # Create unique alert key based on prediction type and minute
                        alert_key = f"{latest_prediction}_{int(time.time() / 60)}"
                        
                        # Send alert if prediction changed to stress/anxiety and not already sent this minute
                        if prediction_changed and alert_key not in alert_sent:
                            print(f"üö® Detected {latest_prediction.upper()} - Sending alert to caretakers...")
                            send_stress_alert(latest_prediction, features_dict)
                            alert_sent[alert_key] = True
                            print(f"‚úÖ Alert sent for {latest_prediction} detection")
                            
                            # Clean old alerts (keep only last hour)
                            current_minute = int(time.time() / 60)
                            alert_sent = {k: v for k, v in alert_sent.items() 
                                        if current_minute - int(k.split('_')[1]) < 60}

                    # Post to IoT server
                    try:
                        iot_payload = {
                            "value1": features_dict["mean_val"],
                            "value2": features_dict["std_val"],
                            "value3": features_dict["peak_amp"],
                            "value4": features_dict["heart_rate"],
                            "value5": features_dict["rr_var"],
                            "value6": features_dict["entropy"],
                            "value7": latest_prediction
                        }
                        r = requests.post(IOT_POST_URL, data=iot_payload, timeout=5)
                        print(f"üì§ Sent to IoT Server: {iot_payload}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è IoT Send Error: {e}")

                    # Therapy recommendation logic
                    if label == last_label:
                        repeat_count += 1
                    else:
                        repeat_count = 1
                        last_label = label

                    # Auto-trigger therapy if same prediction repeats
                    if repeat_count >= 2 and latest_prediction in THERAPY_CONTENT:
                        therapy = random.choice(THERAPY_CONTENT[latest_prediction]["songs"])
                        current_song = therapy
                        # Note: Auto-playing music can be enabled here if desired
                        # webbrowser.open(therapy["url"])
                        print(f"üéµ Therapy recommended: {therapy['name']}")
                        repeat_count = 0

                    # Reset buffer
                    eeg_buffer.clear()
                    start_time = time.time()

                time.sleep(2)

            except Exception as e:
                print(f"‚ö†Ô∏è Monitoring error: {e}")
                time.sleep(2)
        else:
            time.sleep(1)

# Start monitoring thread
monitoring_thread = threading.Thread(target=live_monitoring, daemon=True)
monitoring_thread.start()

# ==========================================
# HELPER FUNCTIONS
# ==========================================
def extract_features(data_buffer):
    """Extract features from EEG data buffer for prediction"""
    if not data_buffer:
        return None, None
        
    data = np.array(data_buffer)
    
    # Calculate features
    mean_val = np.mean(data)
    std_val = np.std(data)
    peak_amp = np.max(data) - np.min(data)
    
    # Simulate Heart Rate and other metrics based on signal characteristics
    # (In a real system, these would be calculated from specific signal bands or sensors)
    heart_rate = 70 + (std_val / 2) + random.uniform(-5, 5)
    rr_var = 50 + random.uniform(-10, 10)
    
    # Simple entropy approximation
    hist, _ = np.histogram(data, bins=10, density=True)
    hist = hist[hist > 0]
    entropy = -np.sum(hist * np.log(hist))
    
    features_dict = {
        "mean_val": float(mean_val),
        "std_val": float(std_val),
        "peak_amp": float(peak_amp),
        "heart_rate": float(heart_rate),
        "rr_var": float(rr_var),
        "entropy": float(entropy)
    }
    
    # Create DataFrame for model
    features_df = pd.DataFrame([features_dict])
    # Ensure columns match model training
    features_df = features_df[['mean_val', 'std_val', 'peak_amp', 'heart_rate', 'rr_var', 'entropy']]
    
    return features_df, features_dict

def convert_numpy_types(obj):
    """Convert numpy types to native Python types for JSON serialization"""
    if isinstance(obj, (np.integer, np.int32, np.int64)):
        return int(obj)
    elif isinstance(obj, (np.floating, np.float32, np.float64)):
        return float(obj)
    elif isinstance(obj, (np.str_, np.bytes_)):
        return str(obj)
    elif isinstance(obj, np.ndarray):
        return obj.tolist()
    elif isinstance(obj, dict):
        return {key: convert_numpy_types(value) for key, value in obj.items()}
    elif isinstance(obj, list):
        return [convert_numpy_types(item) for item in obj]
    else:
        return obj

# ==========================================
# API ENDPOINTS
# ==========================================







@app.route("/api/start_monitoring", methods=['POST'])
def start_monitoring():
    """Start EEG monitoring"""
    global monitoring_active, eeg_buffer, latest_prediction, current_song, session_id
    monitoring_active = True
    eeg_buffer.clear()
    eeg_history.clear()
    latest_prediction = "Monitoring started..."
    current_song = {"name": "None", "url": None}
    session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
    return jsonify({"status": "Monitoring started", "session_id": session_id})

@app.route("/api/stop_monitoring", methods=['POST'])
def stop_monitoring():
    """Stop EEG monitoring"""
    global monitoring_active, latest_prediction
    monitoring_active = False
    latest_prediction = "Monitoring stopped"
    return jsonify({"status": "Monitoring stopped"})

@app.route("/api/status")
def get_status():
    """Get current monitoring status"""
    therapy_content = THERAPY_CONTENT.get(latest_prediction, THERAPY_CONTENT["normal"])
    
    # If monitoring is active and we have recent EEG data, update features in real-time
    if monitoring_active and len(eeg_buffer) > 0:
        try:
            # Calculate real-time features from current buffer
            features_df, features_dict = extract_features(list(eeg_buffer))
            current_features.update(features_dict)
        except Exception as e:
            print(f"‚ö†Ô∏è Error calculating real-time features: {e}")
    
    return jsonify({
        "latest_prediction": latest_prediction,
        "current_song": current_song,
        "monitoring_active": monitoring_active,
        "features": convert_numpy_types(current_features),
        "therapy_content": therapy_content,
        "session_id": session_id
    })

@app.route("/api/second_by_second_features")
def get_second_by_second_features():
    """Analyze all second-by-second readings from current session and return feature ranges"""
    try:
        if not session_id:
            return jsonify({
                "mean_val": None, "std_val": None, "peak_amp": None,
                "heart_rate": None, "rr_var": None, "entropy": None,
                "mean_range": None, "std_range": None, "peak_range": None,
                "hr_range": None, "rr_range": None, "entropy_range": None
            })
        
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        
        # Get all second-by-second readings with their features from current session
        c.execute('''SELECT ed.mean_val, ed.std_val, ed.peak_amp, ed.heart_rate, 
                     ed.rr_var, ed.entropy
                     FROM eeg_data ed
                     WHERE ed.session_id = ?
                     ORDER BY ed.timestamp ASC''', (session_id,))
        
        rows = c.fetchall()
        conn.close()
        
        if not rows or len(rows) == 0:
            return jsonify({
                "mean_val": None, "std_val": None, "peak_amp": None,
                "heart_rate": None, "rr_var": None, "entropy": None,
                "mean_range": None, "std_range": None, "peak_range": None,
                "hr_range": None, "rr_range": None, "entropy_range": None
            })
        
        # Extract all values for each feature
        mean_vals = [row[0] for row in rows if row[0] is not None]
        std_vals = [row[1] for row in rows if row[1] is not None]
        peak_amps = [row[2] for row in rows if row[2] is not None]
        heart_rates = [row[3] for row in rows if row[3] is not None]
        rr_vars = [row[4] for row in rows if row[4] is not None]
        entropies = [row[5] for row in rows if row[5] is not None]
        
        # Calculate ranges (min - max) for each feature
        def calc_range(values, decimals=1):
            if not values or len(values) == 0:
                return None
            min_val = min(values)
            max_val = max(values)
            if min_val == max_val:
                return f"{min_val:.{decimals}f}".replace('.', ',')
            return f"{min_val:.{decimals}f} - {max_val:.{decimals}f}".replace('.', ',')
        
        # Get latest values for current display
        latest_mean = mean_vals[-1] if mean_vals else None
        latest_std = std_vals[-1] if std_vals else None
        latest_peak = peak_amps[-1] if peak_amps else None
        latest_hr = heart_rates[-1] if heart_rates else None
        latest_rr = rr_vars[-1] if rr_vars else None
        latest_entropy = entropies[-1] if entropies else None
        
        return jsonify({
            "mean_val": latest_mean,
            "std_val": latest_std,
            "peak_amp": latest_peak,
            "heart_rate": latest_hr,
            "rr_var": latest_rr,
            "entropy": latest_entropy,
            "mean_range": calc_range(mean_vals, 1),
            "std_range": calc_range(std_vals, 1),
            "peak_range": calc_range(peak_amps, 0),
            "hr_range": calc_range(heart_rates, 0),
            "rr_range": calc_range(rr_vars, 0),
            "entropy_range": calc_range(entropies, 1)
        })
    except Exception as e:
        print(f"‚ö†Ô∏è Error analyzing second-by-second features: {e}")
        return jsonify({
            "mean_val": None, "std_val": None, "peak_amp": None,
            "heart_rate": None, "rr_var": None, "entropy": None,
            "mean_range": None, "std_range": None, "peak_range": None,
            "hr_range": None, "rr_range": None, "entropy_range": None
        })

# ==========================================
# ROUTES
# ==========================================
@app.route("/")
def index():
    """Login page"""
    if 'caretaker_id' in session:
        return redirect(url_for('dashboard'))
    return render_template('login.html')

@app.route("/dashboard")
def dashboard():
    """Caretaker Dashboard"""
    if 'caretaker_id' not in session:
        return redirect(url_for('index'))
    return render_template('dashboard.html')

@app.route("/caretaker-registration")
def caretaker_registration_page():
    """Caretaker registration page"""
    return render_template('caretaker_registration.html')

@app.route("/api/eeg_data")
def get_eeg_data():
    """Get recent EEG data for visualization"""
    return jsonify({
        "history": list(eeg_history),
        "current": list(eeg_buffer)[-50:] if len(eeg_buffer) > 0 else []
    })

@app.route("/api/latest_readings")
def get_latest_readings():
    """Get latest second-by-second readings for real-time display"""
    try:
        if not session_id:
            return jsonify({"readings": [], "count": 0})
            
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        
        # Get all readings from current session (from start to end) with predictions
        c.execute('''SELECT er.timestamp, er.eeg_value, ed.prediction, ed.heart_rate, 
                     ed.mean_val, ed.std_val, ed.peak_amp, ed.rr_var, ed.entropy
                     FROM eeg_readings er
                     LEFT JOIN eeg_data ed ON ABS((julianday(er.timestamp) - julianday(ed.timestamp)) * 86400) < 10
                     WHERE er.session_id = ?
                     ORDER BY er.timestamp ASC''', (session_id,))
        
        rows = c.fetchall()
        conn.close()
        
        readings = []
        for row in rows:
            readings.append({
                "timestamp": row[0],
                "eeg_value": row[1] if row[1] is not None else 0,
                "prediction": row[2] if row[2] else None,
                "heart_rate": row[3] if row[3] is not None else None,
                "mean_val": row[4] if row[4] is not None else None,
                "std_val": row[5] if row[5] is not None else None,
                "peak_amp": row[6] if row[6] is not None else None,
                "rr_var": row[7] if row[7] is not None else None,
                "entropy": row[8] if row[8] is not None else None
            })
        
        # Data is already in chronological order (ASC)
        
        return jsonify({
            "readings": readings,
            "count": len(readings)
        })
    except Exception as e:
        print(f"‚ö†Ô∏è Error fetching latest readings: {e}")
        return jsonify({"readings": [], "count": 0})

@app.route("/api/minute_prediction")
def get_minute_prediction():
    """Analyze second-by-second readings from the last minute and return the latest prediction"""
    try:
        if not session_id:
            return jsonify({"prediction": None, "message": "No active session"})
        
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        
        # Get readings from the last 60 seconds (1 minute)
        one_minute_ago = (datetime.now() - timedelta(seconds=60)).isoformat()
        
        # Get all readings from the last minute with their associated predictions
        c.execute('''SELECT er.timestamp, er.eeg_value, ed.prediction, ed.heart_rate, 
                     ed.mean_val, ed.std_val, ed.peak_amp, ed.rr_var, ed.entropy
                     FROM eeg_readings er
                     LEFT JOIN eeg_data ed ON ABS((julianday(er.timestamp) - julianday(ed.timestamp)) * 86400) < 10
                     WHERE er.session_id = ? AND er.timestamp >= ?
                     ORDER BY er.timestamp DESC''', (session_id, one_minute_ago))
        
        rows = c.fetchall()
        conn.close()
        
        if not rows or len(rows) == 0:
            return jsonify({
                "prediction": None,
                "message": "No readings in the last minute",
                "readings_count": 0
            })
        
        # Analyze predictions from the last minute
        predictions = []
        eeg_values = []
        heart_rates = []
        
        for row in rows:
            if row[1] is not None:  # eeg_value
                eeg_values.append(row[1])
            if row[3] is not None:  # heart_rate
                heart_rates.append(row[3])
            if row[2]:  # prediction
                predictions.append(row[2].lower())
        
        # Determine prediction based on analysis
        final_prediction = None
        
        # Method 1: Use most common prediction from the minute
        if predictions:
            from collections import Counter
            prediction_counts = Counter(predictions)
            most_common = prediction_counts.most_common(1)[0]
            final_prediction = most_common[0]
            confidence = most_common[1] / len(predictions)
        else:
            # Method 2: Analyze features if no predictions available
            if eeg_values and len(eeg_values) >= 10:
                try:
                    features_df, features_dict = extract_features(eeg_values)
                    if model:
                        label = model.predict(features_df)[0]
                        if hasattr(label, 'item'):
                            label = label.item()
                        final_prediction = str(label).lower()
                    else:
                        # Fallback: analyze heart rate
                        avg_heart_rate = np.mean(heart_rates) if heart_rates else features_dict.get('heart_rate', 0)
                        if avg_heart_rate > 100:
                            final_prediction = "anxiety"
                        elif avg_heart_rate > 85:
                            final_prediction = "stress"
                        else:
                            final_prediction = "normal"
                except Exception as e:
                    print(f"‚ö†Ô∏è Error analyzing features: {e}")
                    # Fallback: use heart rate analysis
                    if heart_rates:
                        avg_hr = np.mean(heart_rates)
                        if avg_hr > 100:
                            final_prediction = "anxiety"
                        elif avg_hr > 85:
                            final_prediction = "stress"
                        else:
                            final_prediction = "normal"
                    else:
                        final_prediction = "normal"
            else:
                final_prediction = "normal"  # Default
        
        return jsonify({
            "prediction": final_prediction,
            "readings_count": len(rows),
            "predictions_analyzed": len(predictions),
            "confidence": confidence if predictions else 0.5,
            "timestamp": datetime.now().isoformat()
        })
    except Exception as e:
        print(f"‚ö†Ô∏è Error analyzing minute prediction: {e}")
        return jsonify({
            "prediction": None,
            "message": f"Error: {str(e)}",
            "readings_count": 0
        })

@app.route("/api/test_connection")
def test_connection():
    """Test EEG board connection to IoT endpoint - checks both EEG board AND WiFi"""
    try:
        # First check WiFi connectivity
        try:
            wifi_test = requests.get("https://www.google.com", timeout=3)
            wifi_connected = wifi_test.status_code == 200
        except:
            wifi_connected = False
        
        if not wifi_connected:
            return jsonify({
                "status": "error",
                "message": "WiFi/Internet not connected - Please check your network connection",
                "endpoint": IOT_READ_URL
            }), 503
        
        # Then check EEG board connection
        response = requests.get(IOT_READ_URL, timeout=5)
        if response.status_code == 200:
            data = response.json()
            # Try to extract EEG value
            eeg_value = None
            if "value1" in data:
                eeg_value = float(data.get("value1", 0))
            elif "eeg_value" in data:
                eeg_value = float(data.get("eeg_value", 0))
            elif "value" in data:
                eeg_value = float(data.get("value", 0))
            elif isinstance(data, (int, float)):
                eeg_value = float(data)
            elif isinstance(data, list) and len(data) > 0:
                eeg_value = float(data[0])
            else:
                for key, val in data.items():
                    try:
                        eeg_value = float(val)
                        break
                    except (ValueError, TypeError):
                        continue
            
            if eeg_value is not None:
                return jsonify({
                    "status": "connected",
                    "message": "EEG Board Connected Successfully!",
                    "data_received": data,
                    "eeg_value": eeg_value,
                    "timestamp": datetime.now().isoformat(),
                    "endpoint": IOT_READ_URL
                })
            else:
                return jsonify({
                    "status": "error",
                    "message": "EEG Board Not Connected - Could not extract EEG value from response",
                    "data_received": data,
                    "endpoint": IOT_READ_URL
                }), 400
        else:
            return jsonify({
                "status": "error",
                "message": "EEG Board Not Connected - HTTP " + str(response.status_code),
                "endpoint": IOT_READ_URL
            }), 400
    except requests.exceptions.Timeout:
        return jsonify({
            "status": "error",
            "message": "EEG Board Not Connected - Connection timeout",
            "endpoint": IOT_READ_URL
        }), 408
    except requests.exceptions.ConnectionError:
        return jsonify({
            "status": "error",
            "message": "EEG Board Not Connected - Connection error",
            "endpoint": IOT_READ_URL
        }), 503
    except Exception as e:
        return jsonify({
            "status": "error",
            "message": "EEG Board Not Connected - " + str(e),
            "endpoint": IOT_READ_URL
        }), 500

@app.route("/connection-test")
def connection_test_page():
    """Connection test page"""
    return render_template('connection_test.html')

@app.route("/api/therapy/<prediction_type>")
def get_therapy(prediction_type):
    """Get therapy content for a specific prediction type"""
    therapy = THERAPY_CONTENT.get(prediction_type, THERAPY_CONTENT["normal"])
    return jsonify(therapy)

@app.route("/api/trigger_therapy", methods=['POST'])
def trigger_therapy():
    """Manually trigger therapy"""
    global current_song
    data = request.json
    prediction_type = data.get("type", latest_prediction)
    therapy = THERAPY_CONTENT.get(prediction_type, THERAPY_CONTENT["normal"])
    
    # Ensure we pick a new song if possible
    songs = therapy["songs"]
    if len(songs) > 1 and current_song.get("name") != "None":
         # Filter out the currently playing song to force a change
         available_songs = [s for s in songs if s["name"] != current_song.get("name")]
         if available_songs:
             selected_song = random.choice(available_songs)
         else:
             selected_song = random.choice(songs)
    else:
        selected_song = random.choice(songs)
        
    # Update global current song
    current_song = selected_song
        
    return jsonify({
        "status": "success",
        "song": selected_song,
        "techniques": therapy["techniques"]
    })

@app.route("/api/history")
def get_history():
    """Get historical aggregated data (predictions)"""
    hours = request.args.get('hours', 24, type=int)
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    cutoff_time = (datetime.now() - timedelta(hours=hours)).isoformat()
    c.execute('''SELECT timestamp, eeg_value, mean_val, std_val, peak_amp, 
                 heart_rate, rr_var, entropy, prediction 
                 FROM eeg_data 
                 WHERE timestamp > ? 
                 ORDER BY timestamp DESC 
                 LIMIT 1000''', (cutoff_time,))
    rows = c.fetchall()
    conn.close()
    
    history = []
    for row in rows:
        history.append({
            "timestamp": row[0],
            "eeg_value": row[1],
            "mean_val": row[2],
            "std_val": row[3],
            "peak_amp": row[4],
            "heart_rate": row[5],
            "rr_var": row[6],
            "entropy": row[7],
            "prediction": row[8]
        })
    
    return jsonify({"history": history})

@app.route("/api/detailed_history")
def get_detailed_history():
    """Get second-by-second detailed EEG readings with timeline"""
    hours = request.args.get('hours', 24, type=int)
    session = request.args.get('session_id', None, type=str)
    limit = request.args.get('limit', 10000, type=int)
    
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    cutoff_time = (datetime.now() - timedelta(hours=hours)).isoformat()
    
    if session:
        c.execute('''SELECT timestamp, eeg_value, session_id, reading_index 
                     FROM eeg_readings 
                     WHERE session_id = ? AND timestamp > ? 
                     ORDER BY timestamp ASC 
                     LIMIT ?''', (session, cutoff_time, limit))
    else:
        c.execute('''SELECT timestamp, eeg_value, session_id, reading_index 
                     FROM eeg_readings 
                     WHERE timestamp > ? 
                     ORDER BY timestamp ASC 
                     LIMIT ?''', (cutoff_time, limit))
    
    rows = c.fetchall()
    
    # Get corresponding predictions for context
    if session:
        c.execute('''SELECT timestamp, prediction, mean_val, std_val, peak_amp, 
                     heart_rate, rr_var, entropy 
                     FROM eeg_data 
                     WHERE session_id = ? AND timestamp > ? 
                     ORDER BY timestamp ASC''', (session, cutoff_time))
    else:
        c.execute('''SELECT timestamp, prediction, mean_val, std_val, peak_amp, 
                     heart_rate, rr_var, entropy 
                     FROM eeg_data 
                     WHERE timestamp > ? 
                     ORDER BY timestamp ASC 
                     LIMIT 1000''', (cutoff_time,))
    
    predictions = {}
    for row in c.fetchall():
        predictions[row[0]] = {
            "prediction": row[1],
            "mean_val": row[2],
            "std_val": row[3],
            "peak_amp": row[4],
            "heart_rate": row[5],
            "rr_var": row[6],
            "entropy": row[7]
        }
    
    conn.close()
    
    readings = []
    for row in rows:
        timestamp = row[0]
        # Find closest prediction for this reading
        closest_prediction = None
        for pred_time, pred_data in predictions.items():
            if abs((datetime.fromisoformat(timestamp) - datetime.fromisoformat(pred_time)).total_seconds()) < 10:
                closest_prediction = pred_data
                break
        
        readings.append({
            "timestamp": timestamp,
            "eeg_value": row[1],
            "session_id": row[2],
            "reading_index": row[3],
            "prediction": closest_prediction
        })
    
    return jsonify({
        "readings": readings,
        "total_count": len(readings),
        "time_range": {
            "start": readings[0]["timestamp"] if readings else None,
            "end": readings[-1]["timestamp"] if readings else None
        }
    })

@app.route("/history")
def history_page():
    """Detailed history view page"""
    return render_template('history.html')

def generate_eeg_csv():
    """Generate CSV file with EEG activity data"""
    try:
        if not session_id:
            return None
        
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        
        # Get all readings from current session
        c.execute('''SELECT er.timestamp, er.eeg_value, er.reading_index,
                     ed.prediction, ed.heart_rate, ed.mean_val, ed.std_val, 
                     ed.peak_amp, ed.rr_var, ed.entropy
                     FROM eeg_readings er
                     LEFT JOIN eeg_data ed ON ABS((julianday(er.timestamp) - julianday(ed.timestamp)) * 86400) < 10
                     WHERE er.session_id = ?
                     ORDER BY er.timestamp ASC''', (session_id,))
        
        rows = c.fetchall()
        conn.close()
        
        if not rows:
            return None
        
        # Create CSV in memory
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow(['Index', 'Timestamp', 'Date', 'Time', 'EEG Value', 'Prediction', 
                        'Heart Rate (bpm)', 'Mean Value', 'Std Deviation', 'Peak Amplitude (ŒºV)', 
                        'RR Variance (ms¬≤)', 'Entropy'])
        
        # Write data rows
        for row in rows:
            timestamp = row[0]
            dt = datetime.fromisoformat(timestamp)
            date_str = dt.strftime('%Y-%m-%d')
            time_str = dt.strftime('%H:%M:%S')
            
            writer.writerow([
                row[2] if row[2] else '',  # reading_index
                timestamp,
                date_str,
                time_str,
                f"{row[1]:.2f}" if row[1] is not None else '',  # eeg_value
                row[3] if row[3] else '',  # prediction
                f"{row[4]:.1f}" if row[4] is not None else '',  # heart_rate
                f"{row[5]:.2f}" if row[5] is not None else '',  # mean_val
                f"{row[6]:.2f}" if row[6] is not None else '',  # std_val
                f"{row[7]:.2f}" if row[7] is not None else '',  # peak_amp
                f"{row[8]:.2f}" if row[8] is not None else '',  # rr_var
                f"{row[9]:.2f}" if row[9] is not None else ''   # entropy
            ])
        
        csv_content = output.getvalue()
        output.close()
        return csv_content
    except Exception as e:
        print(f"‚ö†Ô∏è Error generating CSV: {e}")
        return None

@app.route("/api/add_patient", methods=['POST'])
def add_patient():
    """Add a new patient for the logged-in caretaker"""
    if 'caretaker_id' not in session:
        return jsonify({"status": "error", "message": "Unauthorized"}), 401
    
    try:
        data = request.json
        name = data.get("name", "").strip()
        age = data.get("age")
        gender = data.get("gender")
        medical_history = data.get("medical_history", "")
        caretaker_id = session['caretaker_id']
        
        if not name:
            return jsonify({"status": "error", "message": "Patient name is required"}), 400
            
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''INSERT INTO patients (caretaker_id, name, age, gender, medical_history, created_at)
                     VALUES (?, ?, ?, ?, ?, ?)''',
                  (caretaker_id, name, age, gender, medical_history, datetime.now().isoformat()))
        conn.commit()
        patient_id = c.lastrowid
        conn.close()
        
        print(f"‚úÖ Patient added: {name} (ID: {patient_id})")
        return jsonify({"status": "success", "message": "Patient added successfully", "patient_id": patient_id})
    except Exception as e:
        print(f"‚ö†Ô∏è Error adding patient: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route("/api/get_patients")
def get_patients():
    """Get all patients for the logged-in caretaker"""
    if 'caretaker_id' not in session:
        return jsonify({"status": "error", "message": "Unauthorized"}), 401
        
    try:
        caretaker_id = session['caretaker_id']
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''SELECT id, name, age, gender, medical_history FROM patients 
                     WHERE caretaker_id = ? ORDER BY created_at DESC''', (caretaker_id,))
        patients = []
        for row in c.fetchall():
            patients.append({
                "id": row[0],
                "name": row[1],
                "age": row[2],
                "gender": row[3],
                "medical_history": row[4]
            })
        conn.close()
        return jsonify({"patients": patients})
    except Exception as e:
        print(f"‚ö†Ô∏è Error fetching patients: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route("/api/send_alert", methods=['POST'])
def send_alert():
    """Send alert from system email (cybertechguard28@gmail.com) to specified receiver using provided app password"""
    
    data = request.json
    receiver_email = data.get("receiver_email")
    sender_password = data.get("sender_password")
    
    # Recipient: User input
    if not receiver_email:
        return jsonify({"status": "error", "message": "Receiver email is required."}), 400
        
    recipient_name = "Caretaker" # Generic name since it's manual input

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Get current status
    prediction = latest_prediction
    features = current_features
    
    # Determine color based on prediction
    alert_color = "#ff0000" if prediction.lower() == "anxiety" else "#ff6600" if prediction.lower() == "stress" else "#28a745"
    
    # Construct HTML Body
    email_body = f"""
<!DOCTYPE html>
<html>
<head>
<style>
    body {{ font-family: Arial, sans-serif; color: #333; line-height: 1.6; }}
    .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
    .header {{ display: flex; align-items: center; margin-bottom: 20px; }}
    .warning-icon {{ font-size: 24px; margin-right: 10px; }}
    .alert-title {{ color: #dc3545; font-size: 24px; font-weight: bold; margin: 0; }}
    .card {{ background-color: #f8f9fa; border-radius: 5px; padding: 20px; margin-bottom: 20px; }}
    .patient-info {{ margin-bottom: 15px; }}
    .patient-name {{ font-weight: bold; font-size: 18px; }}
    .stress-level {{ color: {alert_color}; font-weight: bold; }}
    .timestamp {{ color: #666; font-size: 14px; }}
    .table {{ width: 100%; border-collapse: collapse; margin-bottom: 20px; }}
    .table th, .table td {{ padding: 12px; text-align: left; border-bottom: 1px solid #dee2e6; }}
    .table th {{ background-color: #e9ecef; font-weight: bold; }}
    .therapy-section {{ background-color: #e3f2fd; border-radius: 5px; padding: 20px; border-left: 5px solid #2196f3; }}
    .therapy-title {{ color: #0d47a1; font-weight: bold; margin-bottom: 10px; display: flex; align-items: center; }}
    .music-icon {{ margin-right: 10px; }}
    .song-link {{ color: #2196f3; text-decoration: none; }}
</style>
</head>
<body>
    <div class="container">
        <div class="header">
            <span class="warning-icon">‚ö†Ô∏è</span>
            <h1 class="alert-title">Stress Level Alert</h1>
        </div>
        
        <p>Dear {recipient_name},</p>
        
        <div class="card">
            <div class="patient-info">
                <div class="patient-name">Patient: {session.get('current_patient_name', 'Unknown')}</div>
                <div>Detected Stress Level: <span class="stress-level">{prediction.upper()}</span></div>
                <div class="timestamp">Time: {timestamp}</div>
            </div>
        </div>
        
        <h3>Vital Signs Summary:</h3>
        <table class="table">
            <tr>
                <th>Parameter</th>
                <th>Value</th>
            </tr>
            <tr>
                <td>Heart Rate</td>
                <td>{features.get('heart_rate', 0):.1f} bpm</td>
            </tr>
            <tr>
                <td>Mean EEG Value</td>
                <td>{features.get('mean_val', 0):.2f}</td>
            </tr>
            <tr>
                <td>Standard Deviation</td>
                <td>{features.get('std_val', 0):.2f}</td>
            </tr>
             <tr>
                <td>Peak Amplitude</td>
                <td>{features.get('peak_amp', 0):.2f}</td>
            </tr>
             <tr>
                <td>Entropy</td>
                <td>{features.get('entropy', 0):.2f}</td>
            </tr>
        </table>
        
        <div class="therapy-section">
            <div class="therapy-title">
                <span class="music-icon">üéµ</span> Relaxation Music Activated
            </div>
            <p>A calming song has been automatically played for the patient:</p>
            <p><a href="#" class="song-link">Click here to view the song</a></p>
        </div>
        
        <p style="margin-top: 20px; font-size: 12px; color: #999;">
            This is an automated alert from the Brainwave Monitoring System.
        </p>
    </div>
</body>
</html>
"""

    try:
        # Use configured sender (fixed) and provided password (dynamic)
        smtp_user = EMAIL_ADDRESS
        smtp_pass = sender_password
        
        if not smtp_user or not smtp_pass:
             # If no credentials, simulate
             raise smtplib.SMTPAuthenticationError(535, "No credentials provided")

        msg = MIMEMultipart()
        msg['From'] = smtp_user
        msg['To'] = receiver_email
        msg['Subject'] = f"Stress Level Alert - {prediction.upper()} Detected"
        msg.attach(MIMEText(email_body, 'html'))
        
        # Connect and send
        print(f"üîê Verifying App Password for {smtp_user}...")
        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        server.starttls()
        server.login(smtp_user, smtp_pass)
        print("‚úÖ Password Verified. Sending email...")
        
        text = msg.as_string()
        server.sendmail(smtp_user, receiver_email, text)
        server.quit()
        
        print(f"‚úÖ Alert sent successfully to {receiver_email}")
        return jsonify({
            "status": "success", 
            "message": f"Alert sent to {receiver_email}",
            "email_count": 1,
            "sms_count": 0
        })
        
    except smtplib.SMTPAuthenticationError:
        print(f"‚ö†Ô∏è Authentication failed for {smtp_user}. Switching to SIMULATION MODE.")
        print("="*50)
        print(f"üìß [SIMULATED EMAIL] From: {smtp_user}")
        print(f"üìß [SIMULATED EMAIL] To: {receiver_email}")
        print(f"Subject: Stress Level Alert - {prediction.upper()} Detected")
        print("-" * 20)
        print(f"Patient: {session.get('current_patient_name', 'Unknown')}")
        print(f"Status: {prediction.upper()}")
        print(f"Heart Rate: {features.get('heart_rate', 0):.1f} bpm")
        print("="*50)
        
        return jsonify({
            "status": "success", 
            "message": f"Alert SIMULATED (sent to console). Verify App Password for {smtp_user}.",
            "email_count": 0,
            "sms_count": 0,
            "simulated": True
        })
    except Exception as e:
        print(f"‚ùå Email send error: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route("/api/register_caretaker", methods=['POST'])
def register_caretaker():
    """Register a new caretaker with username and password"""
    try:
        data = request.json
        name = data.get("name", "").strip()
        username = data.get("username", "").strip().lower()
        password = data.get("password", "").strip()
        mobile_number = data.get("mobile_number", "").strip()
        email = data.get("email", "").strip().lower()
        
        # Validation
        if not name or not username or not password or not mobile_number or not email:
            return jsonify({"status": "error", "message": "All fields are required"}), 400
        
        # Username validation
        if len(username) < 3:
            return jsonify({"status": "error", "message": "Username must be at least 3 characters"}), 400
        
        # Password validation
        if len(password) < 6:
            return jsonify({"status": "error", "message": "Password must be at least 6 characters"}), 400
        
        # Basic email validation
        if "@" not in email or "." not in email:
            return jsonify({"status": "error", "message": "Invalid email address"}), 400
        
        # Basic mobile validation
        if len(mobile_number) < 10:
            return jsonify({"status": "error", "message": "Invalid mobile number"}), 400
        
        # Hash password
        password_hash = hash_password(password)
        
        # Insert into database
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        try:
            c.execute('''INSERT INTO caretakers 
                        (name, username, password_hash, mobile_number, email, registered_at) 
                        VALUES (?, ?, ?, ?, ?, ?)''',
                     (name, username, password_hash, mobile_number, email, datetime.now().isoformat()))
            conn.commit()
            caretaker_id = c.lastrowid
            conn.close()
            print(f"‚úÖ Caretaker registered: {name} (Username: {username}, Email: {email}, Mobile: {mobile_number})")
            return jsonify({
                "status": "success",
                "message": "Caretaker registered successfully",
                "caretaker_id": caretaker_id
            })
        except sqlite3.IntegrityError as e:
            conn.close()
            error_msg = str(e)
            if "username" in error_msg.lower():
                return jsonify({"status": "error", "message": "Username already taken"}), 400
            else:
                return jsonify({"status": "error", "message": "Email or mobile number already registered"}), 400
    except Exception as e:
        print(f"‚ö†Ô∏è Registration error: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route("/api/get_caretakers")
def get_caretakers():
    """Get all registered caretakers (without password)"""
    try:
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''SELECT id, name, username, mobile_number, email, registered_at, is_active 
                     FROM caretakers 
                     ORDER BY registered_at DESC''')
        caretakers = []
        for row in c.fetchall():
            caretakers.append({
                "id": row[0],
                "name": row[1],
                "username": row[2] if row[2] else "",
                "mobile_number": row[3],
                "email": row[4],
                "registered_at": row[5],
                "is_active": bool(row[6])
            })
        conn.close()
        return jsonify({"caretakers": caretakers})
    except Exception as e:
        print(f"‚ö†Ô∏è Error fetching caretakers: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route("/api/caretaker_login", methods=['POST'])
def caretaker_login():
    """Authenticate caretaker with email/username and password"""
    try:
        data = request.json
        # Accept either email or username
        login_id = data.get("email", "").strip().lower() or data.get("username", "").strip().lower()
        password = data.get("password", "").strip()
        
        if not login_id or not password:
            return jsonify({"status": "error", "message": "Username/Email and password are required"}), 400
        
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        # Check against both email and username
        c.execute('''SELECT id, name, username, password_hash, mobile_number, email, is_active 
                     FROM caretakers 
                     WHERE email = ? OR username = ?''', (login_id, login_id))
        row = c.fetchone()
        conn.close()
        
        if row:
            # Verify password
            if verify_password(password, row[3]):
                if not row[6]: # is_active
                    return jsonify({"status": "error", "message": "Account is inactive. Please contact administrator."}), 403
                
                # Login successful
                session['caretaker_id'] = row[0]
                session['caretaker_name'] = row[1]
                session['caretaker_username'] = row[2]
                session['caretaker_email'] = row[5]
                
                print(f"‚úÖ Caretaker logged in: {row[1]}")
                return jsonify({
                    "status": "success", 
                    "message": "Login successful",
                    "caretaker": {
                        "id": row[0],
                        "name": row[1],
                        "username": row[2],
                        "email": row[5]
                    }
                })
            else:
                print(f"‚ö†Ô∏è Login failed for {login_id}: Invalid password")
                return jsonify({"status": "error", "message": "Invalid credentials"}), 401
        else:
            print(f"‚ö†Ô∏è Login failed for {login_id}: User not found")
            return jsonify({"status": "error", "message": "Invalid credentials"}), 401
    except Exception as e:
        print(f"‚ö†Ô∏è Login error: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500
def caretaker_logout():
    """Logout caretaker"""
    session.pop('caretaker_id', None)
    session.pop('caretaker_name', None)
    session.pop('caretaker_username', None)
    return jsonify({"status": "success", "message": "Logged out successfully"})

@app.route("/caretaker-login")
def caretaker_login_page():
    """Caretaker login page"""
    return render_template('caretaker_login.html')

@app.route("/api/get_sessions")
def get_sessions():
    """Get all available monitoring sessions"""
    try:
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''SELECT DISTINCT session_id 
                     FROM eeg_readings 
                     WHERE session_id IS NOT NULL 
                     ORDER BY session_id DESC 
                     LIMIT 100''')
        sessions = [row[0] for row in c.fetchall()]
        conn.close()
        return jsonify({"sessions": sessions})
    except Exception as e:
        print(f"‚ö†Ô∏è Error fetching sessions: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route("/api/update_caretaker/<int:caretaker_id>", methods=['PUT'])
def update_caretaker(caretaker_id):
    """Update caretaker status"""
    try:
        data = request.json
        is_active = data.get("is_active", True)
        
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('''UPDATE caretakers 
                     SET is_active = ? 
                     WHERE id = ?''', (1 if is_active else 0, caretaker_id))
        conn.commit()
        conn.close()
        return jsonify({"status": "success", "message": "Caretaker updated successfully"})
    except Exception as e:
        print(f"‚ö†Ô∏è Error updating caretaker: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route("/api/delete_caretaker/<int:caretaker_id>", methods=['DELETE'])
def delete_caretaker(caretaker_id):
    """Delete a caretaker"""
    try:
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        c.execute('DELETE FROM caretakers WHERE id = ?', (caretaker_id,))
        conn.commit()
        conn.close()
        return jsonify({"status": "success", "message": "Caretaker deleted successfully"})
    except Exception as e:
        print(f"‚ö†Ô∏è Error deleting caretaker: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

# ==========================================
# MAIN
# ==========================================
if __name__ == "__main__":
    print("üöÄ Starting Brainwave Monitoring and Stress Alert System...")
    print(f"üìä Model: {'Loaded' if model else 'Not available'}")
    print(f"üìß Email notifications: {'Enabled' if EMAIL_ENABLED else 'Disabled'}")
    print("üåê Server starting on http://0.0.0.0:5000")
    app.run(host="0.0.0.0", port=5000, debug=True)


